[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-01-31T11:43:04.008Z","categories_index":"","tags_index":"","author_index":"serverDream"},{"id":"6e55f275df54ecca34efde364facb8dd","title":"数据排序 第1课时","content":"1.桶排序本页面将简要介绍桶排序。\n定义桶排序（英文：Bucket sort）是排序算法的一种，适用于待排序数据值域较大但分布比较均匀的情况。\n过程桶排序按下列步骤进行：\n\n设置一个定量的数组当作空桶；\n遍历序列，并将元素一个个放到对应的桶中；\n对每个不是空的桶进行排序；\n从不是空的桶里把元素再放回原来的序列中。\n\n性质稳定性如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。\n由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。\n时间复杂度桶排序的平均时间复杂度为 O(n + n^2&#x2F;k + k)（将值域平均分成 n块 + 排序 + 重新合并元素），当 k\\approx n 时为 O(n)。\n桶排序的最坏时间复杂度为 O(n^2)。\n实现const int N = 100010;\nint n, w, a[N];\nvector&lt;int> bucket[N];\nvoid insertion_sort(vector&lt;int>&amp; A) &#123;\n  for (int i = 1; i &lt; A.size(); ++i) &#123;\n    int key = A[i];\n    int j = i - 1;\n    while (j >= 0 &amp;&amp; A[j] > key) &#123;\n      A[j + 1] = A[j];\n      --j;\n    &#125;\n    A[j + 1] = key;\n  &#125;\n&#125;\n\nvoid bucket_sort() &#123;\n  int bucket_size = w / n + 1;\n  for (int i = 0; i &lt; n; ++i) &#123;\n    bucket[i].clear();\n  &#125;\n  for (int i = 1; i &lt;= n; ++i) &#123;\n    bucket[a[i] / bucket_size].push_back(a[i]);\n  &#125;\n  int p = 0;\n  for (int i = 0; i &lt; n; ++i) &#123;\n    insertion_sort(bucket[i]);\n    for (int j = 0; j &lt; bucket[i].size(); ++j) &#123;\n      a[++p] = bucket[i][j];\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n2.快速排序快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n1.从数列中挑出一个元素，称为 “基准”（pivot）；\n2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\nvoid Quicksort(int arr[], int low, int high) &#123;\n\tif (low &lt; high) &#123;\n\t\t//双指针，一个指向数组起始，一个指向数组末尾\n\t\tint i = low;\n\t\tint j = high;\n\t\t//将数组的第一个元素作为key寻找它的位置\n\t\t//key找到它的位置后，以它为分界线，左右两个数组分治\n\t\tint key = arr[i];\n\t\twhile (i &lt; j) &#123;\n\t\t\t//两个指针不相遇，且指针指向的值大于key时，不断左移\n\t\t\twhile (i &lt; j &amp;&amp; arr[j] >= key)\n\t\t\t\tj--;\n\t\t\tif (i &lt; j) arr[i] = arr[j];\n\t\t\t//两个指针不相遇，且指针指向的值小于key时，不断右移\n\t\t\twhile (i &lt; j &amp;&amp; arr[i] &lt;= key)\n\t\t\t\ti++;\n\t\t\tif (i &lt; j) arr[j] = arr[i];\n\t\t&#125;\n\t\t//将key放在适合的位置\n\t\tarr[i] = key;\n\t\t//分治\n\t\tQuicksort(arr, low, i - 1);\n\t\tQuicksort(arr, i + 1, high);\n\t&#125;\n&#125;\n\n堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；\n3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n\n// Heapsort.cpp : 定义控制台应用程序的入口点。\n//\n \n#include \"stdafx.h\"\n#include&lt;iostream>\nusing namespace std;\nvoid swap(int arr[], int a, int b)\t\t//交换元素；\n&#123;\n\tint temp = arr[a];\n\tarr[a] = arr[b];\n\tarr[b] = temp;\n&#125;\nvoid adjustHeap(int arr[], int i, int length)\t\t//调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）\n&#123;\n\tint temp = arr[i];//先取出当前元素i\n\tfor (int k = i * 2 + 1; k&lt;length; k = k * 2 + 1)//从i结点的左子结点开始，也就是2i+1处开始\n\t&#123;\n\t\tif (k + 1&lt;length&amp;&amp;arr[k]&lt;arr[k + 1])//如果左子结点小于右子结点，k指向右子结点\n\t\t&#123;\n\t\t\tk++;\n\t\t&#125;\n\t\tif (arr[k] >temp)//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）\n\t\t&#123;\n\t\t\tarr[i] = arr[k];\n\t\t\ti = k;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tarr[i] = temp;//将temp值放到最终的位置\n&#125;\nvoid Heapsort(int arr[], int length)\n&#123;\n\t//1.构建大顶堆\n\tfor (int i = length / 2 - 1; i >= 0; i--)\n\t&#123;\n\t\t//从第一个非叶子结点从下至上，从右至左调整结构\n\t\tadjustHeap(arr, i, length);\n\t&#125;\n\tfor (int j = length - 1; j>0; j--)\n\t&#123;\n\t\tswap(arr, 0, j);//将堆顶元素与末尾元素进行交换\n\t\tadjustHeap(arr, 0, j);//重新对堆进行调整\n\t&#125;\n \n&#125;\nint main()\n&#123;\n\tint arr[9] = &#123; 9,8,7,6,10,4,3,2,1 &#125;;\n\tHeapsort(arr, 9);\n\tfor (int i = 0; i&lt;9; i++)\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n1.把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；\n2.对这两个子序列分别采用归并排序；\n3.将两个排序好的子序列合并成一个最终的排序序列。\n\n/* 初始版本，升序排序 */\n/* 时间复杂度：O(nlbn) 将n个待排序记录归并次数为lbn，一趟归并O(n)\n   空间复杂度：O(n) 递归栈最大深度为[lbn] + 1 ，而辅助数组大小为n\n   稳定：无论最好还是最坏情况时间复杂度都是O(nlbn)\n*/\n \nvoid Merge(int arr[], int n)\n&#123;\n    int temp[n]; // 用一个额外的数组来进行排序\n    int b = 0; // 额外数组的起始位置\n    int mid = n / 2; // mid将数组从中间划分，前后两半都有序\n    int first = 0, second = mid; // 两个有序序列的起始位置\n \t//以下操作类似于将两个数组合并为一个有序数组\n    while (first &lt; mid &amp;&amp; second &lt; n)\n    &#123;\n        if (arr[first] &lt;= arr[second]) // 比较两个序列\n        \t//这步操作相当于把第一个数组的值放到用来排序的数组，接着两个指针后移对下一个值进行操作\n            temp[b++] = arr[first++];\n        else\n            temp[b++] = arr[second++];\n    &#125;\n \n    while(first &lt; mid)  // 将剩余子序列复制到辅助序列中\n            temp[b++] = arr[first++];\n    while(second &lt; n)\n            temp[b++] = arr[second++];\n    for (int i = 0; i &lt; n; ++i) // 辅助序列复制到原序列\n        arr[i] = temp[i];\n&#125;\n \nvoid MergeSort(int arr[], int n)\n&#123;\n    if (n &lt;= 1) // 递归出口\n        return;\n    if (n > 1)\n    &#123;\n        MergeSort(arr, n / 2); // 对前半部分进行归并排序\n        MergeSort(arr + n / 2, n - n / 2); // 对后半部分进行归并排序\n        Merge(arr, n); // 归并两部分\n    &#125;\n&#125;\n\n希尔排序简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n\n1.选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；\n2.按增量序列个数k，对序列进行k 趟排序；\n3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\nvoid shellSort(int a[], int n)  //a -- 待排序的数组, n -- 数组的长度\n&#123;\n    int i,j,gap;   // gap为步长，每次减为原来的一半。\n    for (gap = n / 2; gap > 0; gap /= 2)\n    &#123;\n        // 共gap个组，对每一组都执行直接插入排序\n        for (i = 0 ;i &lt; gap; i++)\n        &#123;\n            for (j = i + gap; j &lt; n; j += gap) \n            &#123; \n                // 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。\n                if (a[j] &lt; a[j - gap])\n                &#123;\n                    int tmp = a[j];\n                    int k = j - gap;\n                    while (k >= 0 &amp;&amp; a[k] > tmp)\n                    &#123;\n                        a[k + gap] = a[k];\n                        k -= gap;\n                    &#125;\n                    a[k + gap] = tmp;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n《小练习》1. [NOIP2006 普及组] 明明的随机数题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n输入格式输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。\n第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。\n输出格式输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。\n第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n样例 #1样例输入 #110\n20 40 32 67 40 20 89 300 400 15\n\n样例输出 #18\n15 20 32 40 67 89 300 400\n\n提示NOIP 2006 普及组 第一题\n2.宇宙总统题目描述地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。\n输入格式第一行为一个整数 $n$，代表竞选总统的人数。\n接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。\n输出格式共两行，第一行是一个整数 $m$，为当上总统的人的号数。\n第二行是当上总统的人的选票。\n样例 #1样例输入 #15\n98765\n12365\n87954\n1022356\n985678\n\n样例输出 #14\n1022356\n\n提示票数可能会很大，可能会到 $100$ 位数字。\n$1 \\leq n \\leq 20$。\n3.魔法照片题目描述一共有 $n$ 个人（以 $1\\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\\bmod 10 +1$，显然类别序号的取值为 $1 \\sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。在排序中，如果两人的 $E_i$ 相同，编号小的优先。\n输入格式第一行输入用空格隔开的两个整数，分别是 $n$ 和 $k$。\n第二行给出了 $10$ 个正整数，分别是 $E_1\\sim E_{10}$。\n第三行给出了 $n$ 个正整数，第 $i$ 个数表示编号为  $i$ 的人的权值 $W_i$。\n输出格式只需输出一行用空格隔开的 $k$ 个整数，分别表示最终的 $W_i$ 从高到低的人的编号。\n样例 #1样例输入 #110 10\n1 2 3 4 5 6 7 8 9 10\n2 4 6 8 10 12 14 16 18 20\n\n样例输出 #110 9 8 7 6 5 4 3 2 1\n\n提示对于 $100%$ 的数据，$1\\leq n\\leq 20000$，$1\\leq k\\leq n$，保证所有数据均在 int 范围之内。\n关于本篇文章出自serverDream的小学同学SepiaTruck34735。\n","slug":"数据排序 第2课时","date":"2024-01-30T11:26:03.000Z","categories_index":"","tags_index":"基础算法","author_index":"serverDream"},{"id":"6e55f275df54ecca34efde364facb8dd","title":"数据排序 第1课时","content":"[引入]​\t信息获取后通常需要进行处理，处理后的信息其目的便于人们的应用。信息处理方法有多种，通常有数据的排序、查找、插入、删除、归并等操作。\n[STD库的排序方法]​\tSTD库中存在一个排序函数，叫sort，这个函数在库algorithm(通过代码#include&lt;algorithm&gt;导入)\n​\tsort函数的使用方法\nsort(头指针,尾指针);\n\n​\t举例:将a数组的下表为1~n项排序\nsort(a+1,a+n+1);&#x2F;&#x2F;下表从0开始\n\n[选择排序]&lt;基本思想&gt;​\t每一趟从待排序的数据元素中选出最小(或最大)的一个元素，顺序放在待排序的数列的最前面，直到全部待排序的数据元素都排序完。\n&lt;代码实现&gt;int a[20005];\nvoid psort(int l, int r) &#123;\t\t\t\t\t&#x2F;&#x2F;此函数的意义:排序a数组的l~r的位置的元素\n\tfor(int i &#x3D; l; i &lt; r; i++) &#123;\t\t\t&#x2F;&#x2F;j&#x3D;i+1，当i&#x3D;r时j(i+1)&gt;r所以,i的枚举是从l~(r-1)\n\t\tminn &#x3D; i;\n\t\tfor(int j &#x3D; i + 1; j &lt;&#x3D; r; j++) &#123;\n\t\t\tif(a[j] &lt; a[minn]) &#123;\t\t\t&#x2F;&#x2F;如过找到比a[minn]小的元素,就标记给minn,如果是逆序排序就将小于号改为大于号\n\t\t\t\tminn &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif(minn !&#x3D; i) &#123;\t\t\t\t\t\t&#x2F;&#x2F;如果i~r中最小的数不是i本身,那么i这个位置的数就与最小的数进行替换\n            int k &#x3D; a[minn];\t\t\t\t&#x2F;&#x2F;进行替换\n            a[minn] &#x3D; a[i];\n            a[i] &#x3D; k;\n        &#125;\n\t&#125;\n    return;\n&#125;\n\n[冒泡排序]&lt;基本思想&gt;​\t冒泡排序的基本思想 冒泡排序是交换排序中一种简单的排序方法。 它的基本思想是对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]&gt;a[j+1]），则将其交换，使最大(或最小)的元素冒到最后的那个位置，最终达到有序化。\n&lt;代码实现&gt;int a[20005];\nvoid msort(int l, int r) &#123;\n    for(int i &#x3D; r; i &gt; l; i--) &#123;\n        bool flag &#x3D; true;\t\t\t\t\t\t\t&#x2F;&#x2F;判断序列是否有序\n        for (int j &#x3D; l; j &lt; i; j++) &#123;\n            if(a[j] &gt; a[j + 1]) &#123;\t\t\t\t\t&#x2F;&#x2F;逆序排序将大于号改为小于号\n                int k &#x3D; a[i];\t\t\t\t\t\t&#x2F;&#x2F;交换\n                a[i] &#x3D; a[j];\n                a[j] &#x3D; k;\n                flag &#x3D; false;\t\t\t\t\t\t&#x2F;&#x2F;进行交换说明不是有序的\n            &#125;\n        &#125;\n        if(flag) &#123;\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;如果使有序的就结束排序\n            break;\n        &#125;\n    &#125;\n    return;\n&#125;\n\n[今日作业]​\t完成下列题目的代码,禁止照抄上面代码(三种方法都使用一遍),写完请发给我。\n​\t谁考了第k名\n【题目描述】在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。\n【输入】第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。\n其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。\n【输出】输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）\n【输入样例】5 3 \n90788001 67.8 \n90788002 90.3 \n90788003 61 \n90788004 68.4 \n90788005 73.9\n\n【输出样例】90788004 68.4\n","slug":"数据排序 第1课时","date":"2024-01-26T13:10:57.000Z","categories_index":"","tags_index":"基础算法","author_index":"serverDream"}]